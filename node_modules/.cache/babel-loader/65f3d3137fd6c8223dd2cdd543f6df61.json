{"ast":null,"code":"import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';\nimport _extends from '@babel/runtime/helpers/extends';\nimport * as React from 'react';\nimport { useCallback, useRef, useEffect } from 'react';\nimport { useGetSetState, useEffectOnce, useUpdateEffect } from 'react-use';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nvar clamp = function clamp(num, lower, upper) {\n  num = num <= upper ? num : upper;\n  num = num >= lower ? num : lower;\n  return num;\n};\n\nvar increment = function increment(progress) {\n  var amount = 0;\n\n  if (progress >= 0 && progress < 0.2) {\n    amount = 0.1;\n  } else if (progress >= 0.2 && progress < 0.5) {\n    amount = 0.04;\n  } else if (progress >= 0.5 && progress < 0.8) {\n    amount = 0.02;\n  } else if (progress >= 0.8 && progress < 0.99) {\n    amount = 0.005;\n  }\n\n  return clamp(progress + amount, 0, 0.994);\n};\n\nvar isRunning = false;\nvar pending = [];\n\nvar next = function next() {\n  isRunning = true;\n  var cb = pending.shift();\n\n  if (cb) {\n    return cb(next);\n  }\n\n  isRunning = false;\n};\n\nvar clear = function clear() {\n  isRunning = false;\n  pending = [];\n};\n\nvar queue = function queue(cb) {\n  pending.push(cb);\n\n  if (!isRunning && pending.length === 1) {\n    next();\n  }\n};\n\nvar handle;\n\nvar cancel = function cancel() {\n  if (handle) {\n    window.cancelAnimationFrame(handle);\n  }\n};\n\nvar timeout = function timeout(callback, delay) {\n  var deltaTime;\n  var start;\n\n  var frame = function frame(time) {\n    start = start || time;\n    deltaTime = time - start;\n\n    if (deltaTime > delay) {\n      callback();\n      return;\n    }\n\n    handle = window.requestAnimationFrame(frame);\n  };\n\n  handle = window.requestAnimationFrame(frame);\n};\n/* istanbul ignore next */\n\n\nvar noop = function noop() {\n  return undefined;\n};\n\nvar initialState = {\n  isFinished: true,\n  progress: 0,\n  sideEffect: noop\n};\n\nvar cleanup = function cleanup() {\n  cancel();\n  clear();\n};\n\nvar useNProgress = function useNProgress(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$animationDuratio = _ref.animationDuration,\n      animationDuration = _ref$animationDuratio === void 0 ? 200 : _ref$animationDuratio,\n      _ref$incrementDuratio = _ref.incrementDuration,\n      incrementDuration = _ref$incrementDuratio === void 0 ? 800 : _ref$incrementDuratio,\n      _ref$isAnimating = _ref.isAnimating,\n      isAnimating = _ref$isAnimating === void 0 ? false : _ref$isAnimating,\n      _ref$minimum = _ref.minimum,\n      minimum = _ref$minimum === void 0 ? 0.08 : _ref$minimum;\n\n  var _useGetSetState = useGetSetState(initialState),\n      get = _useGetSetState[0],\n      setState = _useGetSetState[1];\n\n  var set = useCallback(function (n) {\n    n = clamp(n, minimum, 1);\n\n    if (n === 1) {\n      cleanup();\n      queue(function (next) {\n        setState({\n          progress: n,\n          sideEffect: function sideEffect() {\n            return timeout(next, animationDuration);\n          }\n        });\n      });\n      queue(function () {\n        setState({\n          isFinished: true,\n          sideEffect: cleanup\n        });\n      });\n      return;\n    }\n\n    queue(function (next) {\n      setState({\n        isFinished: false,\n        progress: n,\n        sideEffect: function sideEffect() {\n          return timeout(next, animationDuration);\n        }\n      });\n    });\n  }, [animationDuration, minimum, setState]);\n  var trickle = useCallback(function () {\n    set(increment(get().progress));\n  }, [get, set]);\n  var start = useCallback(function () {\n    var work = function work() {\n      trickle();\n      queue(function (next) {\n        timeout(function () {\n          work();\n          next();\n        }, incrementDuration);\n      });\n    };\n\n    work();\n  }, [incrementDuration, trickle]);\n  var savedTrickle = useRef(noop);\n  var sideEffect = get().sideEffect;\n  useEffect(function () {\n    savedTrickle.current = trickle;\n  });\n  useEffectOnce(function () {\n    if (isAnimating) {\n      start();\n    }\n\n    return cleanup;\n  });\n  useUpdateEffect(function () {\n    get().sideEffect();\n  }, [get, sideEffect]);\n  useUpdateEffect(function () {\n    if (!isAnimating) {\n      set(1);\n    } else {\n      setState(_extends({}, initialState, {\n        sideEffect: start\n      }));\n    }\n  }, [isAnimating, set, setState, start]);\n  return {\n    animationDuration: animationDuration,\n    isFinished: get().isFinished,\n    progress: get().progress\n  };\n};\n\nvar _excluded = [\"children\"];\n\nvar NProgress = function NProgress(_ref) {\n  var children = _ref.children,\n      restProps = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  var renderProps = useNProgress(restProps);\n  return children(renderProps);\n};\n\nfunction withNProgress(BaseComponent) {\n  var WithNProgress = function WithNProgress(props) {\n    var hookProps = useNProgress(props);\n    return /*#__PURE__*/React.createElement(BaseComponent, _extends({}, props, hookProps));\n  };\n\n  hoistNonReactStatics(WithNProgress, BaseComponent);\n  return WithNProgress;\n}\n\nexport { NProgress, useNProgress, withNProgress };","map":{"version":3,"mappings":"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","names":["clamp","num","lower","upper","increment","progress","amount","isRunning","pending","next","cb","shift","clear","queue","push","length","handle","cancel","window","cancelAnimationFrame","timeout","callback","delay","deltaTime","start","frame","time","requestAnimationFrame","noop","undefined","initialState","isFinished","sideEffect","cleanup","cancelCurrentTimeout","clearQueue","useNProgress","animationDuration","incrementDuration","isAnimating","minimum","useGetSetState","get","setState","set","useCallback","n","trickle","work","savedTrickle","useRef","useEffect","current","useEffectOnce","useUpdateEffect","NProgress","children","restProps","renderProps","withNProgress","BaseComponent","WithNProgress","props","hookProps","React","createElement","hoistNonReactStatics"],"sources":["../compiled/clamp.js","../compiled/increment.js","../compiled/queue.js","../compiled/timeout.js","../compiled/useNProgress.js","../compiled/NProgress.js","../compiled/withNProgress.js"],"sourcesContent":["export const clamp = (num, lower, upper) => {\n    num = num <= upper ? num : upper;\n    num = num >= lower ? num : lower;\n    return num;\n};\n","import { clamp } from './clamp';\nexport const increment = (progress) => {\n    let amount = 0;\n    if (progress >= 0 && progress < 0.2) {\n        amount = 0.1;\n    }\n    else if (progress >= 0.2 && progress < 0.5) {\n        amount = 0.04;\n    }\n    else if (progress >= 0.5 && progress < 0.8) {\n        amount = 0.02;\n    }\n    else if (progress >= 0.8 && progress < 0.99) {\n        amount = 0.005;\n    }\n    return clamp(progress + amount, 0, 0.994);\n};\n","let isRunning = false;\nlet pending = [];\nconst next = () => {\n    isRunning = true;\n    const cb = pending.shift();\n    if (cb) {\n        return cb(next);\n    }\n    isRunning = false;\n};\nexport const clear = () => {\n    isRunning = false;\n    pending = [];\n};\nexport const queue = (cb) => {\n    pending.push(cb);\n    if (!isRunning && pending.length === 1) {\n        next();\n    }\n};\n","let handle;\nexport const cancel = () => {\n    if (handle) {\n        window.cancelAnimationFrame(handle);\n    }\n};\nexport const timeout = (callback, delay) => {\n    let deltaTime;\n    let start;\n    const frame = (time) => {\n        start = start || time;\n        deltaTime = time - start;\n        if (deltaTime > delay) {\n            callback();\n            return;\n        }\n        handle = window.requestAnimationFrame(frame);\n    };\n    handle = window.requestAnimationFrame(frame);\n};\n","import { useCallback, useEffect, useRef } from 'react';\nimport { useEffectOnce, useGetSetState, useUpdateEffect } from 'react-use';\nimport { clamp } from './clamp';\nimport { increment } from './increment';\nimport { clear as clearQueue, queue } from './queue';\nimport { cancel as cancelCurrentTimeout, timeout } from './timeout';\n/* istanbul ignore next */\nconst noop = () => undefined;\nconst initialState = {\n    isFinished: true,\n    progress: 0,\n    sideEffect: noop,\n};\nconst cleanup = () => {\n    cancelCurrentTimeout();\n    clearQueue();\n};\nexport const useNProgress = ({ animationDuration = 200, incrementDuration = 800, isAnimating = false, minimum = 0.08, } = {}) => {\n    const [get, setState] = useGetSetState(initialState);\n    const set = useCallback((n) => {\n        n = clamp(n, minimum, 1);\n        if (n === 1) {\n            cleanup();\n            queue((next) => {\n                setState({\n                    progress: n,\n                    sideEffect: () => timeout(next, animationDuration),\n                });\n            });\n            queue(() => {\n                setState({ isFinished: true, sideEffect: cleanup });\n            });\n            return;\n        }\n        queue((next) => {\n            setState({\n                isFinished: false,\n                progress: n,\n                sideEffect: () => timeout(next, animationDuration),\n            });\n        });\n    }, [animationDuration, minimum, setState]);\n    const trickle = useCallback(() => {\n        set(increment(get().progress));\n    }, [get, set]);\n    const start = useCallback(() => {\n        const work = () => {\n            trickle();\n            queue((next) => {\n                timeout(() => {\n                    work();\n                    next();\n                }, incrementDuration);\n            });\n        };\n        work();\n    }, [incrementDuration, trickle]);\n    const savedTrickle = useRef(noop);\n    const sideEffect = get().sideEffect;\n    useEffect(() => {\n        savedTrickle.current = trickle;\n    });\n    useEffectOnce(() => {\n        if (isAnimating) {\n            start();\n        }\n        return cleanup;\n    });\n    useUpdateEffect(() => {\n        get().sideEffect();\n    }, [get, sideEffect]);\n    useUpdateEffect(() => {\n        if (!isAnimating) {\n            set(1);\n        }\n        else {\n            setState({\n                ...initialState,\n                sideEffect: start,\n            });\n        }\n    }, [isAnimating, set, setState, start]);\n    return {\n        animationDuration,\n        isFinished: get().isFinished,\n        progress: get().progress,\n    };\n};\n","import { useNProgress } from './useNProgress';\nexport const NProgress = ({ children, ...restProps }) => {\n    const renderProps = useNProgress(restProps);\n    return children(renderProps);\n};\n","import hoistNonReactStatics from 'hoist-non-react-statics';\nimport * as React from 'react';\nimport { useNProgress } from './useNProgress';\nexport function withNProgress(BaseComponent) {\n    const WithNProgress = (props) => {\n        const hookProps = useNProgress(props);\n        return React.createElement(BaseComponent, { ...props, ...hookProps });\n    };\n    hoistNonReactStatics(WithNProgress, BaseComponent);\n    return WithNProgress;\n}\n"]},"metadata":{},"sourceType":"module"}